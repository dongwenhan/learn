### volatile

可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写
入。
·原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不
具有原子性。

禁止指令重排：





### Java内存模型 （JMM）

JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。
1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

源代码===> 编译器重排===>指令重排===> 内存重排





线程状态

![image-20210210155152955](C:\Users\dongw\AppData\Roaming\Typora\typora-user-images\image-20210210155152955.png)

![image-20210212141242690](C:\Users\dongw\AppData\Roaming\Typora\typora-user-images\image-20210212141242690.png)